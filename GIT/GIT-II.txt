GIT-II
===============
$ git init (создаёт в текущем каталоге новый подкаталог с именем .git содержащий все необходимые файлы репозитория)
$ git status (для определения, какие файлы в каком состоянии находятся)
$ git add README (чтобы начать отслеживать (добавить под версионный контроль) новый файл)
$ git add benchmarks.rb (это многофункциональная команда, она используется для добавления под версионный контроль новых файлов, для индексации изменений, а также для других целей, например для указания файлов с исправленным конфликтом слияния))
===============
.gitignore

	К шаблонам в файле .gitignore применяются следующие правила:

Пустые строки, а также строки, начинающиеся с #, игнорируются.
Можно использовать стандартные glob шаблоны.
Можно заканчивать шаблон символом слэша (/) для указания каталога.
Можно инвертировать шаблон, использовав восклицательный знак (!) в качестве первого символа.


Cимвол * соответствует 0 или более символам; 
последовательность [abc] — любому символу из указанных в скобках (в данном примере a, b или c); 
знак вопроса (?) соответствует одному символу; 
[0-9] соответствует любому символу из интервала (в данном случае от 0 до 9).

	Пример файла .gitignore:

# комментарий — эта строка игнорируется
# не обрабатывать файлы, имя которых заканчивается на .a
*.a
# НЕ игнорировать файл lib.a, несмотря на то, что мы игнорируем все .a файлы с помощью предыдущего правила
!lib.a
# игнорировать только файл TODO находящийся в корневом каталоге, не относится к файлам вида subdir/TODO
/TODO
# игнорировать все файлы в каталоге build/
build/
# игнорировать doc/notes.txt, но не doc/server/arch.txt
doc/*.txt
# игнорировать все .txt файлы в каталоге doc/
doc/**/*.txt

===============
$ git diff (увидеть, что же вы изменили в файле, но пока не проиндексировали)
$ git diff --staged (сравнивает индексированные изменения с последним коммитом = посмотреть, что вы проиндексировали и что войдёт в следующий коммит)

===============
#COMMIT (коммит сохраняет снимок состояния вашего индекса)

$ git commit (простейший способ зафиксировать изменения | комментарий по умолчанию для коммита содержит закомментированный результат работы ("выхлоп") команды git status и ещё одну пустую строку сверху)
$ git commit -v (в комментарий будет также помещена дельта/diff изменений, таким образом вы сможете точно увидеть всё, что сделано)
$ git commit -m "Story 182: Fix benchmarks for speed" (комментарий к коммиту в командной строке вместе с командой commit)
$ git commit -a -m "Story 182: Fix benchmarks for speed" (ключ "-a" позволяет обойтись без git add)


===============

$ git rm 1.txt (удалить файл из Git'а | также удаляет файл из вашего рабочего каталога, так что вы в следующий раз не увидите его как “неотслеживаемый”.)
!!! Если вы просто удалите файл из своего рабочего каталога, он будет показан в секции “Changes not staged for commit”
!!! Затем, если вы выполните команду git rm, удаление файла попадёт в индекс
$ git rm -f 1.txt (Если вы изменили файл и уже проиндексировали его, вы должны использовать принудительное удаление с помощью параметра -f)
$ git rm --cached readme.txt (--cached позволяет удалить файл из индекса, оставив его при этом в рабочем каталоге)
$ git rm log/\*.log (В команду git rm можно передавать файлы, каталоги или glob-шаблоны | обратный слэш (\) перед * необходим из-за того, что Git использует свой собственный обработчик имён файлов)

===============
$ git mv file_from file_to (это одна команда вместо трёх | $ mv README.txt README | $ git rm README.txt | $ git add README)

===============
$ git log (без аргументов, git log выводит список коммитов, где самые последние коммиты показываются первыми)
$ git log -p -2 (-p, который показывает дельту (разницу/diff) и -2, что ограничит вывод до 2-х последних записей)
$ git log -p -1 -U1 --word-diff (--word-diff - показывает изменения по словам | -U1 - будет показана 1 строка вверх и 1 вниз от измененной строки)
$ git log --stat (--stat - краткая статистика по каждому коммиту)
$ git log --pretty=oneline (выводит каждый коммит в одну строку)
$ git log --pretty=format:"%h - %an, %ar : %s" ()

===============
#4 - Отмена изменений
$ git commit --amend (сделать этот коммит ещё раз)
$ git reset HEAD benchmarks.rb (отменим индексацию файла benchmarks.rb | benchmarks.rb изменён, но снова не в индексе)
$ git checkout -- benchmarks.rb (отменяет изменения в файле до состояния последнего индекса)

===============
#5 - Удалённые репозитории
$ git remote (просмотреть, какие удалённые серверы уже настроены)
$ git remote -v (-v = посмотреть, какому URL соответствует сокращённое имя в Git)
$ git remote add [сокращение] [url] (git remote add pb git://github.com/paulboone/ticgit.git - добавить новый удалённый Git-репозиторий)
$ git fetch pb (извлечь (fetch) всю информацию, которая есть в репозитории | команда fetch забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не модифицирует то, над чем вы работаете в данный момент)
$ git pull (как правило, извлекает (fetch) данные с сервера, с которого вы изначально склонировали, и автоматически пытается слить (merge) их с кодом, над которым вы в данный момент работаете.)
$ git push origin master (отправить вашу ветку master на сервер origin)
!!! Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись, и если никто другой с тех пор не выполнял команду push. Если вы и кто-то ещё одновременно клонируете, затем он выполняет команду push, а затем команду push выполняете вы, то ваш push точно будет отклонён. !!!
$ git remote show origin (выдаёт URL удалённого репозитория, а также информацию об отслеживаемых ветках)
$ git remote rename pb paul (переименование удалённого репозитория)
$ git remote rm paul (удаление ссылку на репозиторий)

===============
#6 Метки
#помечать (tag) определённые моменты в истории как важные.

	$ git tag (Просмотр имеющихся меток (tag) в Git'е)
	$ git tag -l 'v1.4.2.*' (поиск по шаблону)

	метки бывают легковесные и аннотированные
		1) Легковесная метка — это что-то весьма похожее на ветку, которая не меняется — это просто указатель на определённый коммит. 
		2) Аннотированные метки - хранятся в базе данных Git'а как полноценные объекты. Они имеют контрольную сумму, содержат имя поставившего метку, e-mail и дату, имеют комментарий и могут быть подписаны и проверены с помощью GNU Privacy Guard (GPG). Обычно рекомендуется создавать аннотированные метки, чтобы иметь всю перечисленную информацию; но если вы хотите сделать временную метку или по какой-то причине не хотите сохранять остальную информацию, то для этого годятся и легковесные метки.

	$ git tag -a v1.4 -m 'my version 1.4' (Создание аннотированной метки, где -m задаёт меточное сообщение)
	$ git tag -s v1.5 -m 'my signed 1.5 tag' (Вы также можете подписывать свои метки с помощью GPG, конечно, если у вас есть ключ. Всё что нужно сделать, это использовать -s вместо -a)
	$ git tag v1.4-lw (Для создания легковесной метки не передавайте опций -a, -s и -m:)
	$ git show v1.5 (прос)

	# Верификация подписи
	$ git tag -v v1.4.2.1 (Эта команда использует GPG для верификации подписи. Вам нужен открытый ключ автора подписи, чтобы команда работала правильно:)

	$ git tag -a v1.2 -m 'version 1.2' 9fceb02 (добавить метку старому коммиту, SHA которого начинается на 9fceb02)
	$ git push origin v1.5 (По умолчанию, команда git push не отправляет метки на удалённые серверы. Необходимо явно отправить (push) метки на общий сервер)
	$ git push origin --tags (все ваши метки отправятся на удалённый сервер (если только их уже там нет).)

===============
#7 Приколюхи

#Псевдонимы
$ git config --global alias.co checkout
$ git config --global alias.br branch
$ git config --global alias.ci commit
$ git config --global alias.st status

$ git config --global alias.unstage 'reset HEAD --' (исключение файла из индекса)
$ git config --global alias.last 'log -1 HEAD' (git last = посмотреть последний коммит)
$ git config --global alias.visual '!gitk' (git visual = gitk)

===============
CHAPTER 3
#8 Ветвление 

$ git branch (список веток)
$ git branch testing (Эта команда создаст новый указатель на тот самый коммит, на котором вы сейчас находитесь)
$ git checkout testing (Это действие передвинет HEAD так, чтобы тот указывал на ветку testing)
$ git checkout -b iss53 (создать ветку и сразу же перейти на неё)
$ git checkout -b имя-новой-ветки aaaaaa (создать ветку с коммита "aaaaaa" и сразу же перейти на неё)

#чтобы влить в ветку master исправления из ветки hotfix
$ git checkout master 
$ git merge hotfix (слить (merge) изменения назад в ветку master, чтобы включить их в продукт)

$ git branch -d hotfix (удалите ветку hotfix, так как она больше не нужна — ветка master уже указывает на то же место)

#Conflicts

$ git merge iss53
Auto-merging index.html
CONFLICT (content): Merge conflict in index.html
Automatic merge failed; fix conflicts and then commit the result.

$ git status (посмотреть, какие файлы не прошли слияние (на любом этапе после возникновения конфликта))

#Управление ветками
$ git branch -v (Чтобы посмотреть последний коммит на каждой из веток, выполните команду git branch -v)
$ git branch --merged (посмотреть ветки, которые вы уже слили с текущей)
$ git branch --no-merged (посмотреть ветки, которые вы еще не слили с текущей)
$ git branch -d testing (ветка testing удалится только если она - предок текущего HEAD)
$ git branch -D testing (ветка testing удалится и все наработки в ней... типа --force что-ли =))

===================================
#Удалённые ветки
— это ссылки на состояние веток в ваших удалённых репозиториях

$ git push origin serverfix - (отправка локальной ветки serverfix на удалённый сервер)
$ git push origin serverfix:serverfix (идентично с предыдущим | здесь говорится “возьми мой serverfix и сделай его удалённым serverfix”)
$ git push origin serverfix:awesomebranch (локальная ветка serverfix отправится в ветку awesomebranch удалённого проекта)

$ git fetch origin (Важно отметить, что когда при получении данных у вас появляются новые удалённые ветки, вы не получаете автоматически для них локальных редактируемых копий. Другими словами, в нашем случае вы не получите новую ветку serverfix — только указатель origin/serverfix, который вы не можете менять.)

$ git merge origin/serverfix (слить наработки в свою текущую рабочую ветку | сработает если текущая ветка не имеет коммитов или имеет коммит-предок от serverfix)
$ git checkout -b serverfix origin/serverfix (создаёт локальную ветку serverfix, над которой вы сможете работать, на основе удалённой ветки origin/serverfix)
$ git checkout --track origin/serverfix (аналогично предыдущему | создаётся ОТСЛЕЖИВАЕМАЯ ВЕТКА, где git push и git pull работают автоматом)

#Удаление веток на удалённом сервере
$ git push origin :serverfix (== 'отправь в ветку serverfix удалённого репозитория origin пустоту')

======================================
#6-Перемещение в Git (rebase) (В Git'е есть два способа включить изменения из одной ветки в другую: merge (слияние) и rebase (перемещение). )

#перемещение выполняется для того, чтобы история была более аккуратной.
#Перемещение применяет изменения из одной линии разработки в другую в том порядке, в котором они были представлены, тогда как слияние объединяет вместе конечные точки двух веток.

$ git checkout experiment
$ git rebase master (текущая ветка experiment переместится на ветку master, при этом все дельты experiment начиная с общего предка, применятся на ветку master)

$ git rebase --onto master server client (По сути, это указание “переключиться на ветку client, взять изменения от общего предка веток client и server и повторить их на master”.)

$ git rebase master server (применит изменения из вашей работы над веткой server на вершину ветки master)
!!!!!!!!Не перемещайте коммиты, которые вы уже отправили в публичный репозиторий.!!!!!!!


===========================
ERRORS:

(1) 
git clone >>> SSL certificate problem: self signed certificate in certificate chain 
RESOLUTION : $ git config --global http.sslVerify false

===========================
ДОПОЛНИТЕЛЬНО

$ git ls-files -s (просмотр файлов в индексе)

$ git ls-files --stage
100644 63c918c667fa005ff12ad89437f2fdc80926e21c 0   .gitignore
100644 5529b198e8d14decbe4ad99db3f7fb632de0439d 0   .mailmap

create patch from concrete commit
$ git format-patch -1 98ce896114cf75abc2991ca79f13cfb319a18919 -o patches
